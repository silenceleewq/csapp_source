# 第2章: 信息的表示和处理

## 2.1 信息储存
字节 (byte): 8位的块, 最小的可寻址的内存单位.每次寻址至少是一个字节, 多则4个字节, 8个字节等.

虚拟内存(virtual memory): 机器级程序将内存视为一个非常大的字节数组, 这就叫做虚拟内存.(内存本身不是字节数组, 所以这个非常大的字节数组被称为虚拟的.)

地址 (address): 内存的每个字节都由一个唯一的数字来标识, 称为地址.

虚拟地址空间 (virtual address space): 所有的地址 (address) 的集合就称为 虚拟地址空间.

程序对象 (program object): 程序数据, 指令和控制信息.


## 2.1.1 十六进制表示法

十六进制数 (hexadecimal): 以 16 为基数, 满16进1. 因为二进制太冗长, 十进制与位模式的互相转换太麻烦, 所以用Hex. 0~9 A~F, 以 0X 或 0x 开头的数字.

练习题:

A. 将 0x39A7F8 转换为二进制    
B. 将二进制 1100100101111011 转换为十六进制.  
C. 将 0xD5E4C 转换为二进制.  
D. 将二进制 1001101110011110110101 转换为十六机制.  

解:    
A. 0x39A7F8 -> 0011 1001 1010 0111 1111 1000   
B. 1100 1001 0111 1011 -> 0xC97B  
C. 0xD5E4C -> 1101 0101 1110 0100 1100  
D. 10 0110 1110 0111 1011 0101 -> 0x26E7B5



当值 _x_ 是 2 的非负整数 _n_ 次幂时, 可以写成 n = i + 4j 的形式, 0 ≤ i ≤ 3, 可以把 _x_ 写成开头为16进制数: 1(i=0), 2(i=1), 4(i=2), 8(i=3), 后面跟着 _j_ 十六进制的0. 比如: _x_ = 2048 = 2<sup>11</sup>, n = 11 = 3 + 4 · 2. 从而得到十六进制: 0x800.
> 个人理解: 因为十六进制的1位需要用4位二进制来表示. 所以当 _j_ 为 1 的时候, 意味着有4个0, j 为 2的时候, 有8个0, i 只有4种情况, 0001, 0010, 0100, 1000, 分别对应了, 1, 2, 4, 8, 所以, i 只能取 0 到 3 之间. 因为 2<sup>0-3</sup> = [1, 2, 4, 8].  大致就是这个原理.



## 2.1.2 字数据大小
字长 (word size): 指明指针数据的标称大小( nominal size ), 虚拟地址以字长来编码, 所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小. 也就是说对于一个字长为 w 位的机器而言, 虚拟地址的范围为 0~2<sup>w</sup>-1, 程序最多访问 2<sup>w</sup> 个字节.
> 32位字长限制虚地址空间为4千兆字节(4GB),扩展到64位字长, 虚拟空间地址为 16EB (1EB = 1024PB, 1PB = 1024TB)这里涉及到操作系统的内存管理...

![image](/Users/lirenqiang1/csapp_source/source/2-3 data size.png)

为了避免因为机器的不同而导致数据类型的大小不一, C99引入了 int32_t & int64_t 来精确控制数据的大小.

一般的数据类型编码都是有符号数值, 除非前面有 unsigned 关键字来特别声明无符号.

char类型,大多数编译器和机器视为有符号数, 但C标准不保证这一点.

## 2.1.3 寻址和字节顺序

一个 _w_ 位的整数, 其位表示为  [_x_<sub>w-1</sub>, _x_<sub>w-2</sub>,..._x_<sub>1</sub>, _x_<sub>0</sub>,], 其中 _x_<sub>w-1</sub> 是高有效位, 而 _x_<sub>0</sub> 是低有效位, 假设 _w_ 是 8 的倍数, 这些位就能被分组成为字节, 其中最高有效字节包含位 [_x_<sub>w-1</sub>, _x_<sub>w-2</sub>,..._x_<sub>w-7</sub>, _x_<sub>w-8</sub>,], 而最低有效字节包含[_x_<sub>7</sub>, _x_<sub>6</sub>,..._x_<sub>1</sub>, _x_<sub>0</sub>,].  

机器在内存中按照从最低有效字节到最高有效字节排序, 有些则反之.  

小端法 (little endian): 最低有效字节在最前面的方式. 

大端法 (big endian) : 最高有效字节在最前面.

假设 x 的类型为 int, 首地址位 0x100, 十六进制为 0x01234567.  

大端法: 0x100 -> 01, 0x101 -> 23, 0x102 -> 45, 0x103 -> 57

小端法: 0x100 -> 67, 0x101 -> 45, 0x102 -> 23, 0x104 -> 01.

Android & iOS 都是小端法.

当阅读汇编的字节级表示的时候, 大端和小端的排序就显得比较重要了, 这决定了你怎样来读取指令.

## 2.1.4 表示字符串
C 语言的字符串被编码为一个以 null (值为0) 字符结尾的字符数组.

每个字符都以某个标准码来表示,最常见的是 ASCII 码, (Mac 终端可以用 `man ascii` 命令来打印出 ASCII 码的列表)

`show_bytes("12345", 6);` 来运行的话,得到的结果为: 31 32 33 34 35 00, 这里的12345正好对应ASCII的31 32 33 34 35.

在使用 ASCII 的系统上, 上面的函数调用的到的结果,都是相同的, 与字节的顺序和大小规则无关, 所以, 文本数据比二进制数据具有更强的平台独立性.

## 2.1.5 表示代码
![image](/Users/lirenqiang1/csapp_source/source/2-1-5Code.png)
不同的机器类型使用不同的且不兼容的指令和编码方式. 即使完全一样的进程, 运行在不同的操作系统上也会有不同的编码规则, 因此二进制代码是不兼容的.

从机器角度来看, 程序仅仅只是字节序列.

## 2.1.6 布尔代数简介





<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


